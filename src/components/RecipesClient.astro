---
import Recipe from "./Recipe.astro";
import Chip from "./Chip.astro";
import SearchBar from "./SearchBar";
import "../pages/_recipes.scss";

interface Props {
  recipes: any[];
}

const { recipes } = Astro.props;

const normalizeRecipe = (recipe: any) => ({
  ...recipe,
  tags: Array.isArray(recipe.tags) ? recipe.tags.map((tag: string) => tag.toLowerCase()) : [],
});

const combinedRecipes = recipes.map(normalizeRecipe);

// Shuffle
for (let i = combinedRecipes.length - 1; i > 0; i--) {
  const j = Math.floor(Math.random() * (i + 1));
  [combinedRecipes[i], combinedRecipes[j]] = [combinedRecipes[j], combinedRecipes[i]];
}

// Get all unique tags
const allTags = new Set(
  combinedRecipes.flatMap((recipe) => recipe.tags || [])
);
---

<div id="recipes-container">
  <div class="searchContainer">
    <SearchBar client:load />
  </div>
  <div class="chips" id="tag-chips">
    {[...allTags].sort().map((tag) => (
      <Chip
        label={tag}
        data-tag={tag}
        active={false}
      />
    ))}
  </div>
  <div class="recipes" id="recipes-list">
    {combinedRecipes.map((recipe) => (
      <div
        class="recipe-wrapper"
        data-recipe-id={recipe.id}
        data-recipe-title={recipe.title.toLowerCase()}
        data-recipe-tags={JSON.stringify(recipe.tags)}
      >
        <Recipe
          title={recipe.title}
          image={recipe.image}
          source={recipe.source}
          tags={recipe.tags}
          notes={recipe.notes}
          type={recipe.type}
          slug={recipe.slug}
          tagFilters={[]}
        />
      </div>
    ))}
  </div>
</div>

<style>
  .recipe-wrapper {
    opacity: 0;
    transform: translateY(20px);
    transition: opacity 0.3s ease-out, transform 0.3s ease-out;
  }

  .recipe-wrapper.visible {
    opacity: 1;
    transform: translateY(0);
  }
</style>

<script>
  // Intersection Observer for lazy loading
  const observerOptions = {
    root: null,
    rootMargin: '50px',
    threshold: 0.1
  };

  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        entry.target.classList.add('visible');
        observer.unobserve(entry.target);
      }
    });
  }, observerOptions);

  // Observe all recipe wrappers
  document.querySelectorAll('.recipe-wrapper').forEach(wrapper => {
    observer.observe(wrapper);
  });

  // Client-side interactivity for filtering and search
  let activeFilters = new Set<string>();
  let searchTerm = '';

  function updateRecipeDisplay() {
    const recipeWrappers = document.querySelectorAll('.recipe-wrapper');

    recipeWrappers.forEach((wrapper) => {
      const titleAttr = wrapper.getAttribute('data-recipe-title');
      const tagsAttr = wrapper.getAttribute('data-recipe-tags');

      if (!titleAttr || !tagsAttr) return;

      const title = titleAttr;
      const tags = JSON.parse(tagsAttr);

      // Check search term
      const matchesSearch = !searchTerm || title.includes(searchTerm.toLowerCase());

      // Check filters
      const matchesFilters = activeFilters.size === 0 ||
        Array.from(activeFilters).every(filter => tags.includes(filter));

      if (matchesSearch && matchesFilters) {
        (wrapper as HTMLElement).style.display = '';
      } else {
        (wrapper as HTMLElement).style.display = 'none';
      }
    });

    // Update visible tags based on search results
    updateVisibleTags();
  }

  function updateVisibleTags() {
    const visibleRecipes = Array.from(document.querySelectorAll('.recipe-wrapper'))
      .filter((wrapper) => (wrapper as HTMLElement).style.display !== 'none');

    const visibleTags = new Set<string>();
    visibleRecipes.forEach((wrapper) => {
      const tagsAttr = wrapper.getAttribute('data-recipe-tags');
      if (tagsAttr) {
        const tags = JSON.parse(tagsAttr);
        tags.forEach((tag: string) => visibleTags.add(tag));
      }
    });

    // Show/hide tag chips based on visibility
    const allChips = document.querySelectorAll('#tag-chips .chip');
    allChips.forEach((chip) => {
      const tag = chip.getAttribute('data-tag');
      if (tag && !visibleTags.has(tag)) {
        (chip as HTMLElement).style.display = 'none';
      } else {
        (chip as HTMLElement).style.display = '';
      }
    });
  }

  // Listen for search events from the MUI SearchBar component
  window.addEventListener('recipeSearch', (e: Event) => {
    const customEvent = e as CustomEvent;
    searchTerm = customEvent.detail.value;
    updateRecipeDisplay();
  });

  // Chip click handlers
  const chips = document.querySelectorAll('.chip[data-tag]');
  chips.forEach((chip) => {
    chip.addEventListener('click', () => {
      const tag = chip.getAttribute('data-tag');
      if (!tag) return;

      if (activeFilters.has(tag)) {
        activeFilters.delete(tag);
        chip.classList.remove('active');
      } else {
        activeFilters.add(tag);
        chip.classList.add('active');
      }

      updateRecipeDisplay();
    });

    // Keyboard support
    chip.addEventListener('keydown', (event) => {
      const e = event as KeyboardEvent;
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        (event.target as HTMLElement).click();
      }
    });
  });

  // Recipe tag chip handlers
  document.addEventListener('click', (e) => {
    const target = e.target as HTMLElement;
    const recipeChip = target.closest('.recipe__body__chips .chip[data-tag]');

    if (recipeChip) {
      const tag = recipeChip.getAttribute('data-tag');
      if (!tag) return;

      // Find corresponding filter chip and toggle it
      const filterChip = document.querySelector(`#tag-chips .chip[data-tag="${tag}"]`);
      if (filterChip) {
        (filterChip as HTMLElement).click();
      }
    }
  });
</script>
